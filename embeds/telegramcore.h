// This file generated by libqtelegram-code-generator.
// You can download it from: https://github.com/Aseman-Land/libqtelegram-code-generator
// DO NOT EDIT THIS FILE BY HAND -- YOUR CHANGES WILL BE OVERWRITTEN

#ifndef TELEGRAMCORE_H
#define TELEGRAMCORE_H

#include <QObject>
#include <QPointer>
#include <QTimerEvent>
#include <functional>

#include "telegramapi.h"
#include "telegramcore_globals.h"
#include "libqtelegram_global.h"

class TelegramApi;
class LIBQTELEGRAMSHARED_EXPORT TelegramCore : public QObject
{
    Q_OBJECT
public:
    TelegramCore(QObject *parent = 0);
    ~TelegramCore();

    class CallbackError {
    public:
        CallbackError() : errorCode(0), null(true) {}
        qint32 errorCode;
        QString errorText;
        bool null;
    };

    template<typename T>
    using Callback = std::function<void (qint64,T,CallbackError)>;

    static CallbackError apiError() {
        CallbackError error;
        error.errorCode = -1;
        error.errorText = "LIBQTELEGRAM_API_ERROR";
        error.null = false;
        return error;
    }

    static qint32 timeOut() { return mTimeOut; }
    static void setTimeOut(const qint32 &timeOut) { mTimeOut = timeOut; }

    QVariantHash lastArguments() const {
        return mLastArgs;
    }

    virtual void init() = 0;
    bool isConnected() const;

/*! === methods === !*/

Q_SIGNALS:
/*! === signals === !*/
    void error(qint64 id, qint32 errorCode, const QString &errorText, const QString &functionName);

protected Q_SLOTS:
/*! === events === !*/
    virtual void onError(qint64 id, qint32 errorCode, const QString &errorText, const QString &functionName, const QVariant &attachedData, bool &accepted);

protected:
    qint64 retry(qint64 msgId);
    void timerEvent(QTimerEvent *e);

    void setApi(TelegramApi *api);
    QPointer<TelegramApi> mApi;

    void stopTimeOut(qint64 msgId) {
        qint32 timer = mTimer.take(msgId);
        if(timer) killTimer(timer);
    }

    void startTimeOut(qint64 msgId, int timeOut) {
        stopTimeOut(msgId);
        if(!timeOut) return;
        mTimer[msgId] = startTimer(timeOut);
    }

    template<typename T>
    void callBackPush(qint64 msgId, Callback<T> callback) {
        if(!callback || mCallbacks.contains(msgId)) return;
        void *ptr = new Callback<T>(callback);
        mCallbacks[msgId] = ptr;
    }

    template<typename T>
    Callback<T> callBackGet(qint64 msgId) {
        void *ptr = mCallbacks.value(msgId);
        if(!ptr) return 0;
        Callback<T> *callBack = reinterpret_cast<Callback<T>*>(ptr);
        return (*callBack);
    }

    template<typename T>
    void callBackCall(qint64 msgId, const T &result, const CallbackError &error = CallbackError()) {
        Callback<T> callBack = callBackGet<T>(msgId);
        void *ptr = mCallbacks.take(msgId);
        if(!ptr) return;
        callBack(msgId, result, error);
        delete reinterpret_cast<Callback<T>*>(ptr);
    }

private:
    QHash<qint64, void*> mCallbacks;
    QHash<qint64, QVariantHash> mRecallArgs;
    QVariantHash mLastArgs;
    QHash<qint64, qint32> mTimer;
    static qint32 mTimeOut;

    /*! === privates === !*/
};

#endif // TELEGRAMCORE_H
